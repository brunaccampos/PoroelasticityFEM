function ComputeError_Time()
% ------------------------------------------------------------------------
% Compute error using the Le norm of the displacements
% ------------------------------------------------------------------------

clearvars
clear, clc
close all

%% Number of sims
nsims = 5;

nsd = 1;
L = 50; % t end
type = 'L2';

%% Mesh 1
% load file
load Results_m1Boone0.05Spanos.mat
% mesh
ne1 = Control.dt; % dt
Mesh1 = Build1DMesh(nsd, ne1, L, type);
% FEM approximation
d1 = Plot.p;
% exact solution
d_exact1 = Plot.pan_time;

%% Mesh 2
load Results_m2Boone0.05Spanos.mat
% mesh
ne2 = Control.dt; % dt
Mesh2 = Build1DMesh(nsd, ne2, L, type);
% FEM approximation
d2 = Plot.p;
% exact solution
d_exact2 = Plot.pan_time;

%% Mesh 3
load Results_m3Boone0.05Spanos.mat
% mesh
ne3 = Control.dt; % dt
Mesh3 = Build1DMesh(nsd, ne3, L, type);
% FEM approximation
d3 = Plot.p;
% exact solution
d_exact3 = Plot.pan_time;

%% Mesh 4
load Results_m4Boone0.05Spanos.mat
% mesh
ne4 = Control.dt; % dt
Mesh4 = Build1DMesh(nsd, ne4, L, type);
% FEM approximation
d4 = Plot.p;
% exact solution
d_exact4 = Plot.pan_time;

%% Mesh 5
load Results_m5Boone0.05Spanos.mat
% mesh
ne5 = Control.dt; % dt
Mesh5 = Build1DMesh(nsd, ne5, L, type);
% FEM approximation
d5 = Plot.p;
% exact solution
d_exact5 = Plot.pan_time;

%% Compute L2 error norm
% initialize variables
eL2 = zeros(nsims,1);
h = zeros(nsims,1);

% loop over meshes
for sim = 1:nsims
    switch sim
        case 1
            d = d1;
            d_exact = d_exact1;
            Mesh = MeshU1;
        case 2
            d = d2;
            d_exact = d_exact2;
            Mesh = Mesh2;
        case 3
            d = d3;
            d_exact = d_exact3;
            Mesh = Mesh3;
        case 4
            d = d4;
            d_exact = d_exact4;
            Mesh = Mesh4;
        case 5
            d = d5;
            d_exact = d_exact5;
            Mesh = Mesh5;
        case 6
            d = d6;
            d_exact = d_exact6;
            Mesh = Mesh6;
    end
    
    % Mesh size
    switch MeshP.nsd
        case 1
            h(sim) = max(MeshP.coords)/MeshP.ne;
            MeshP.xdofs = MeshP.DOF;
            MeshP.ydofs = zeros(length(MeshP.DOF),1);
            Mesh.xdofs = Mesh.DOF;
            Mesh.ydofs = zeros(length(Mesh.DOF),1);
        case 2
            gcoords = MeshP.coords(MeshP.conn(1,:),:);
            h(sim) = sqrt(polyarea(gcoords(:,1),gcoords(:,2)));
    end
    
    % Calculate error norms
    eL2_num = 0;
    eL2_den = 0;
    
    % loop over elements
    for i = 1:Mesh.ne
        % element connectivity
        conn_e = Mesh.conn(i,:);
        % global coordinates
        gcoords = Mesh.coords(conn_e,:);
                
        % loop over integration points
        for ip = 1:Quad.nq
            % N matrices
            N = getN(Mesh, Quad, ip);
            % N derivatives
            dN = getdN(Mesh, Quad, ip);
            % Jacobian matrix
            J = dN*gcoords;
            % Jacobian determinant
            Jdet = det(J);
            
            % approximated displacement at quadrature point
            switch Mesh.nsd
                case 1
                    % approximated displacement at quadrature point
                    uxh_p = Np*dp(MeshP.xdofs(connp_e)');
                    uyh_p = zeros(length(uxh_p));
                    uxh_u = N*d(Mesh.xdofs(conn_e)');
                    uyh_u = zeros(length(uxh_u));
                    % exact displacement at quadrature point
                    uxe_p = Np*dp_exact(MeshP.xdofs(connp_e));
                    uye_p = zeros(length(uxe_p));
                    uxe_u = N*d_exact(Mesh.xdofs(conn_e));
                    uye_u = zeros(length(uxe_u));

                case 2
                    % approximated displacement at quadrature point
                    uxh_p = Np*dp(MeshP.xdofs(connp_e)');
                    uyh_p = Np*dp(MeshP.ydofs(connp_e)');
                    uxh_u = N*d(Mesh.xdofs(conn_e)');
                    uyh_u = N*d(Mesh.ydofs(conn_e)');
                    % exact displacement at quadrature point
                    uxe_p = Np*dp_exact(MeshP.xdofs(connp_e)');
                    uye_p = Np*dp_exact(MeshP.ydofs(connp_e)');
                    uxe_u = N*d_exact(Mesh.xdofs(conn_e)');
                    uye_u = N*d_exact(Mesh.ydofs(conn_e)');
            end

            % L2 norm pressure
            eL2p_num = eL2p_num + [uxh_p - uxe_p , uyh_p - uye_p] * [uxh_p - uxe_p ; uyh_p - uye_p] * Quad.w(ip,1) * Jdet;
            eL2p_den = eL2p_den + [uxe_p , uye_p] * [uxe_p ; uye_p] * Quad.w(ip,1) * Jdet;
            % L2 norm displacement
            eL2_num = eL2_num + [uxh_u - uxe_u , uyh_u - uye_u] * [uxh_u - uxe_u ; uyh_u - uye_u] * Quad.w(ip,1) * Jdet;
            eL2_den = eL2_den + [uxe_u , uye_u] * [uxe_u ; uye_u] * Quad.w(ip,1) * Jdet;
        end
    end
    
    eL2p(sim) = sqrt(eL2p_num);
    eL2(sim) = sqrt(eL2_num);
end

% Determine slope of L2 norm
% pL2 = polyfit(log(h(1:2)), log(eL2p(1:2)),1);
% m_L2 = pL2(1);

%% Step 2 - Calculate the slope of each curve

figure;
loglog(h,eL2p,'m-o', 'LineWidth', 1.5);
hold on
loglog(h,normp,'b-o', 'LineWidth', 1.5);
hold off
xlabel('Mesh size (m)');
ylabel('L2-norm');
title('Convergence for pressure');

figure;
loglog(h,eL2,'g-o', 'LineWidth', 1.5);
% hold on
% loglog(h,normu,'k-o', 'LineWidth', 1.5);
% hold off
xlabel('Mesh size (m)');
ylabel('L2-norm');
title('Convergence for displacement');


end